"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Unsplash_instances, _Unsplash_withErrorHandling;
Object.defineProperty(exports, "__esModule", { value: true });
const got = require('got').default;
const Provider = require('../Provider');
const { getURLMeta } = require('../../helpers/request');
const adaptData = require('./adapter');
const { withProviderErrorHandling } = require('../providerErrors');
const { prepareStream } = require('../../helpers/utils');
const { ProviderApiError } = require('../error');
const BASE_URL = 'https://api.unsplash.com';
const getClient = ({ token }) => got.extend({
    prefixUrl: BASE_URL,
    headers: {
        authorization: `Client-ID ${token}`,
    },
});
const getPhotoMeta = async (client, id) => client.get(`photos/${id}`, { responseType: 'json' }).json();
/**
 * Adapter for API https://api.unsplash.com
 */
class Unsplash extends Provider {
    constructor() {
        super(...arguments);
        _Unsplash_instances.add(this);
    }
    async list({ token, query = { cursor: null, q: null } }) {
        if (typeof query.q !== 'string') {
            throw new ProviderApiError('Search query missing', 400);
        }
        return __classPrivateFieldGet(this, _Unsplash_instances, "m", _Unsplash_withErrorHandling).call(this, 'provider.unsplash.list.error', async () => {
            const qs = { per_page: 40, query: query.q };
            if (query.cursor)
                qs.page = query.cursor;
            const response = await getClient({ token }).get('search/photos', { searchParams: qs, responseType: 'json' }).json();
            return adaptData(response, query);
        });
    }
    async download({ id, token }) {
        return __classPrivateFieldGet(this, _Unsplash_instances, "m", _Unsplash_withErrorHandling).call(this, 'provider.unsplash.download.error', async () => {
            const client = getClient({ token });
            const { links: { download: url, download_location: attributionUrl } } = await getPhotoMeta(client, id);
            const stream = got.stream.get(url, { responseType: 'json' });
            await prepareStream(stream);
            // To attribute the author of the image, we call the `download_location`
            // endpoint to increment the download count on Unsplash.
            // https://help.unsplash.com/en/articles/2511258-guideline-triggering-a-download
            await client.get(attributionUrl, { prefixUrl: '', responseType: 'json' });
            // finally, stream on!
            return { stream };
        });
    }
    async size({ id, token }) {
        return __classPrivateFieldGet(this, _Unsplash_instances, "m", _Unsplash_withErrorHandling).call(this, 'provider.unsplash.size.error', async () => {
            const { links: { download: url } } = await getPhotoMeta(getClient({ token }), id);
            const { size } = await getURLMeta(url, true);
            return size;
        });
    }
}
_Unsplash_instances = new WeakSet(), _Unsplash_withErrorHandling = 
// eslint-disable-next-line class-methods-use-this
async function _Unsplash_withErrorHandling(tag, fn) {
    // @ts-ignore
    return withProviderErrorHandling({
        fn,
        tag,
        providerName: 'Unsplash',
        getJsonErrorMessage: (body) => (body === null || body === void 0 ? void 0 : body.errors) && String(body.errors),
    });
};
module.exports = Unsplash;
